public class Bezier extends PApplet {
  
  class Vector2 {
    double x,y; double deltaX = 0; double deltaY = 0;

    public Vector2(double x, double y){ this.x = x; this.y = y; }
    public Vector2 add(double other){ this.x += other; this.y += other; return this; }
    public Vector2 add(Vector2 other){ this.x += other.x; this.y += other.y; return this; }
    public Vector2 mult(double other){ this.x *= other; this.y *= other; return this; }
    public Vector2 mult(Vector2 other){ this.x *= other.x; this.y *= other.y; return this; }

    @Override
    public String toString(){ return String.format("<{0}, {1}>", this.x, this.y); }
  }

  class BezierCurve {
    private ArrayList<Vector2> waypoints  = new ArrayList<Vector2>();
    public BezierCurve(Vector2[] points) {
      for(Vector2 point : points){
        waypoints.add(point);
      }
    }

    private double frac(int x){
      if(x == 0) return 1.0;
      return x * frac(x-1);
    }

    public Vector2 getPoint(Double u){
      int size = waypoints.size();
      Vector2 sum = new Vector2(0,0);
      for(int i = 0; i < waypoints.size(); i++){
        sum = sum.add(waypoints.get(i).mult(
          frac(size) / frac(i) / frac(size-i) * Math.pow(u,i) * Math.pow(1-i, size-i)
        ));
      }
      return sum;
    }

    public void addPoint(Vector2 point){ waypoints.add(point); }
  }
  
  int dragIndex;
  boolean isDraggingHandleWithOppHandle;
  boolean isDraggingAnchor;
  
  Vector2 drag;
  Vector2 anchor;
  
  boolean drawConnections = true;
  boolean drawHandles = true;
  boolean drawAnchors = true;
  
  final int splineSize = 30;
  final int pointsPerSpline = 50;
   ArrayList<Vector2> points = new ArrayList();
  // ArrayList<BezierCurve> splines = new ArrayList();
  BezierCurve spline = new BezierCurve();

  void setup()
  {
    surface.setSize(1000, 700);
  }
  
  void draw()
  {
    background(100);
    for(int i = 0; i < points.size(); i++){
      Vector2 point = points.get(i);
      stroke(60);
      if(i>0 && drawConnections){
        line((float) points.get(i).x, (float) points.get(i).y, (float) points.get(i-1).x, (float) points.get(i-1).y);
      }
      stroke(225);
      if(drawHandles || (drawAnchors && isAnchor(i))){
        circle((float) point.x, (float) point.y, 5.0);
      }
    }
    // noFill();
    drawSplines();
    // fill(255);
  }
  
  void drawSplines(){
    Vector2 point;
    //for(BezierCurve spline: waypoints){
      for(double i=0; i<=1; i+= 1.0/pointsPerSpline){
        point = spline.getPoint(i);
        circle((float) point.x, (float) point.y, 30.0f);
      }
    //}
  }
    
  boolean hasOppHandle(int index){ return index % 3 != 0 && index != 1 && (index % 3 != 2 || index + 2 < points.size()); }
  boolean isAnchor(int index){ return index % 3 == 0; }
  int getOppHandleIndex(int index) { return index % 3 == 1 ? index - 2 : index + 2; }
  int getAnchorIndex(int index) { return index % 3 == 1 ? index - 1 : index + 1; }
  
  void addPoint(int x, int y){
    println("add point");
    spline.addPoint(new Vector2(x,y));
    // if(anchor == null){
    //     anchor = new Vector2(x, y);
    //     points.add(anchor);
    //   }
    //   else{
    //     if(points.size() > 1){
    //       points.add(
    //         points.size()-1, 
    //         new Vector2( anchor.x*2 - x, anchor.y*2 - y)
    //       );
    //     }
    //     points.add(anchor);
    //     points.add(new Vector2(x, y));
    //     anchor = null;
    //   }
  }
  
  void movePoint(){
    for(int i = 0;i < points.size();i++){
          Vector2 point = points.get(i);
          if(Math.sqrt(Math.pow(point.x - mouseX, 2) + Math.pow(point.y - mouseY, 2)) < hoverDistance){
            drag = point;
            if(hasOppHandle(i)) {
              dragOppHandle = points.get(getOppHandleIndex(i));
              dragAnchor = points.get(getAnchorIndex(i));    
            }
            else if(isAnchor(i)){
              if(i > 0){
                  dragHandle1 = points.get(i-1);
              }
              if(i < points.size()){
                  dragHandle2 = points.get(i+1);
              }
            }
            if(keyCode == 16 && keyPressed){
              if(drag == anchor){
                anchor = null;
              }
              points.remove(drag);
              points.remove(dragOppHandle);
              points.remove(dragAnchor);
              points.remove(dragHandle1);
              points.remove(dragHandle2);
            }
            break;
          }
      }
  }
  
  
  void mousePressed(){
    if(mouseButton == RIGHT){
      addPoint(mouseX, mouseY);
    }
    // else if(mouseButton == LEFT){
    //   movePoint();
    // }
  }
  
  void mouseDragged(){
    if(drag == null) return
    drag.x = mouseX;
    drag.y = mouseY;
  }
  
  void mouseReleased(){
    drag = null;
  }
  
  void keyPressed(){ 
    if(key == ' '){
      if (drawConnections) drawConnections = false;
      else if (drawHandles) drawHandles = false;
      else if (drawAnchors) drawAnchors = false;
      else {
        drawConnections = true;
        drawHandles = true;
        drawAnchors = true;
      }
    }
  }
  
  void mouseMoved(){
    
  }
  
  Vector2 csit(Vector2 a, Vector2 b, Vector2 c, Vector2 d, double t){
    //t^3*a + 3*t^2*(1-t)*b + 3*t*(1-t)^2*c + (1-t)^3*d
    return d.mult(Math.pow(t,3))
      .add(c.mult(3*Math.pow(t,2)*(1-t)))
      .add(b.mult(3*t*Math.pow(1-t,2)))
      .add(a.mult(Math.pow(1-t,3)));
  }
}
